/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "stm32f10x.h"
#include <string.h>
#include <stdio.h>
#include "ff.h"
#include "DIALOG.h"

extern WM_HWIN g_hItem[5];
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0    (GUI_ID_USER + 0x02)
#define ID_LISTBOX_0    (GUI_ID_USER + 0x04)


// USER START (Optionally insert additional defines)
#define HEX_NAME_LEN                51          //LCD显示的文件名的最大长度
#define FILE_NUMBER_MUX             100         //LCD显示的文件名的最大个数
#define _DF1S                       0x81
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static u8  g_u8fileNum = 0;
static u8  g_u8fileNumOld = 0;
static unsigned char lcdlist[FILE_NUMBER_MUX][HEX_NAME_LEN];
static FATFS fs;               /* Work area (file system object) for logical drives */
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "FileList", ID_WINDOW_0, 0, 0, 128, 128, 0, 0x0, 0 },
  { LISTBOX_CreateIndirect, "Listbox", ID_LISTBOX_0, 5, 5, 118, 118, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
/**
  * @brief  scan_files    扫描sd卡内的HEX文件
  * @param  path:  扫描路径
  * @retval result:  文件系统的返回值
  */
static void scan_files (char* path) 
{
  FILINFO finfo; 
  
  DIR dir; 
  int i=0;
  uint8_t j=0;
  char *fn;
  char *result;
  
#if _USE_LFN 
  static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1]; 	//长文件名支持
  finfo.lfname = lfn; 
  finfo.lfsize = sizeof(lfn); 
#endif
  
  for(j=0;j<FILE_NUMBER_MUX;j++)
    for(i=0;i<HEX_NAME_LEN;i++)
      lcdlist[j][i]='\0';
  g_u8fileNumOld = g_u8fileNum+1;   //防止上一次文件数为零，而添加的 "No Hex file"
  g_u8fileNum = 0;
  
  if( f_mount(0,&fs) == FR_OK)
  {
    if (f_opendir(&dir, path) == FR_OK)               /* 打开根目录 */
    {
      while(f_readdir(&dir, &finfo) == FR_OK)
      {
        if ( finfo.fattrib & AM_ARC )           /* 判断是否为存档型文档 */
        {
          #if _USE_LFN 
          fn = *finfo.lfname ? finfo.lfname : finfo.fname; 
          #else 
          fn = finfo.fname; 
          #endif
          
          #if _USE_LFN 
          if( !finfo.lfname[0] )              /* 文件名为空即到达了目录的末尾，退出 */
          #else
          if( !finfo.fname[0] )               
          #endif
            break;
          
          #if _USE_LFN 
          result = strstr( finfo.lfname, ".hex" );
          #else
          result = strstr( finfo.fname, ".hex" );
          #endif
          
          if ( result != NULL)
          {
            memcpy(lcdlist[g_u8fileNum], fn, (strlen(fn) < HEX_NAME_LEN)? strlen(fn) : HEX_NAME_LEN);						
            if(g_u8fileNum < (FILE_NUMBER_MUX))
            {
                g_u8fileNum++;                             //记录文件个数
            }
            //printf("file_num = %d\r\n", file_num);
          }
        }
      }
    }
    f_mount(0,NULL);
  }
} 
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  uint8_t i = 0;
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Listbox'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTBOX_0);
    LISTBOX_SetFont(hItem, GUI_FONT_13_1);
    // USER START (Optionally insert additional code for further widget initialization)
    LISTBOX_SetAutoScrollV(hItem, 1);
    scan_files("");
    
    for(i=0;i<g_u8fileNumOld;i++)
    {
      LISTBOX_DeleteItem(hItem, 0);
    }
    
    if(g_u8fileNum)
    {
      for(i=0;i<g_u8fileNum;i++)
      {
        LISTBOX_AddString(hItem, (char *)lcdlist[i]);
      }
    }
    else
    {
      LISTBOX_AddString(hItem, "No Hex file");
    }
    
    WM_SetFocus(hItem);
    LISTBOX_SetSel(hItem, 0);
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_LISTBOX_0: // Notifications sent by 'Listbox'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  case WM_KEY:
    switch (((WM_KEY_INFO*)(pMsg->Data.p))->Key)
    {
      case GUI_KEY_ENTER:
        hItem = WM_GetDialogItem(g_hItem[3], 0x804);//ID_TEXT_0
        TEXT_SetText(hItem, "0");
        WM_HideWindow(g_hItem[0]);
        WM_HideWindow(g_hItem[1]); 
        WM_HideWindow(g_hItem[2]); 
        WM_ShowWindow(g_hItem[3]); 
        WM_SetFocus(g_hItem[3]);
        break;
      case GUI_KEY_ESCAPE:
        printf("BACKTA\r\n");
        WM_ShowWindow(g_hItem[0]); //Home
        WM_HideWindow(g_hItem[1]); //main
        WM_HideWindow(g_hItem[2]); //Filelist
        WM_SetFocus(g_hItem[0]);
      
      break;
    }
    break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateFileList
*/
WM_HWIN CreateFileList(void);
WM_HWIN CreateFileList(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
